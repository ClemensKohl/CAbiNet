% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clustering.R
\name{run_caclust}
\alias{run_caclust}
\title{Run biclustering}
\usage{
run_caclust(
  caobj,
  k_sym,
  k_asym = k_sym,
  algorithm = "leiden",
  SNN_prune = 1/15,
  loops = FALSE,
  mode = "out",
  select_genes = TRUE,
  prune_overlap = TRUE,
  overlap = 0.2,
  calc_gene_cell_kNN = FALSE,
  resolution = 1,
  marker_genes = NULL,
  n.int = 10,
  rand_seed = 2358,
  use_gap = TRUE,
  nclust = NULL,
  python = TRUE,
  spectral_method = "kmeans",
  iter.max = 10,
  num.seeds = 10,
  return.eig = TRUE,
  sc.dims = NULL,
  leiden.dense = TRUE
)
}
\arguments{
\item{caobj}{A cacomp object with principal and standard coordinates
calculated.}

\item{k_sym}{k for cell-cell and gene-gene kNN graph}

\item{k_asym}{k for cell-gene and gene-cell kNN graph}

\item{algorithm}{Algorithm for clustering. Options are "leiden" or "spectral".}

\item{SNN_prune}{numeric. Value between 0-1. Sets cutoff of acceptable jaccard
similarity scores for neighborhood overlap of vertices in SNN. Edges with values
less than this will be set as 0. The default value is 1/15.}

\item{loops}{TRUE/FALSE. If TRUE self-loops are allowed, otherwise not.}

\item{mode}{The type of neighboring vertices to use for calculating similarity
scores(Jaccard Index). Three options: "out", "in" and "all":
\itemize{
\item "out": Selecting neighbouring vertices by out-going edges;
\item "in": Selecting neighbouring vertices by in-coming edges;
\item "all": Selecting neigbouring vertices by both in-coming and out-going edges.
}}

\item{select_genes}{TRUE/FALSE. Should genes be selected by whether they have
an edge in the cell-gene kNN graph?}

\item{prune_overlap}{TRUE/FALSE. If TRUE edges to genes that share less
than `overlap` of genes with the nearest neighbours of the cell are removed.
Pruning is only performed if select_genes = TRUE.}

\item{overlap}{Numeric between 0 and 1. Overlap cutoff if
prune_overlap = TRUE.}

\item{calc_gene_cell_kNN}{TRUE/FALSE. If TRUE a cell-gene graph is calculated
by choosing the `k_gc` nearest cells for each gene. If FALSE the cell-gene
graph is transposed.}

\item{resolution}{resolution for leiden algorithm.}

\item{n.int}{Number of iterations for leiden algorithm.}

\item{rand_seed}{Random seed.}

\item{use_gap}{TRUE/FALSE. If TRUE, 'eigengap' method will be used to find the
most important eigenvector automatically, and the number of output clusters 
equals number of selected eigenvectors. If FALSE, 'nclust'(integer) should be given. 
The eigenvectors corresponding with the smallest 'nclust' eigenvalues will be
selcted and 'nclust' clusters will be detected by skmeans.}

\item{python}{TRUE/FALSE. If TRUE, pytorch function will be used to do eigenvalue
decompositon, else R-base function 'svd' will be used for calculation.}
}
\value{
Returns list:
\itemize{
\item 'cell_clusters': factor vector containing assigned clusters for the cell
specified in the elements name.
\item 'gene_clusters': factor vector containing assigned clusters for the genes
specified in the elements name.
\item 'umap_coords': If \code{return_umap = TRUE} additionally a data frame with
the umap_coordinates of cells and genes is returned.
}
}
\description{
TODO
}
